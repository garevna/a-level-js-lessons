<a name="top"></a>
## :mortar_board: Методы массивов

| [`pop()`](#1) | [`push()`](#2) | [`splice()`](#5) |
|-|-|-|
| [**`shift()`**](#3) | [**`unshift()`**](#4) | [**`slice()`**](#6) |
| [**`concat()`**](#7) | [**`join()`**](#8) | [**`includes()`**](#9) |

***

<a name="1"></a>
### :memo: pop ()

| [:arrow_double_down:](#bottom) | <img width="800"/> | [:arrow_heading_down:](#2) |
|-|-|-|

Этот метод удаляет последний элемент массива и возвращает удаленный элемент

У метода нет параметров ( аргументов )

:coffee:

```javascript
var myArray = [ "Гвоздь", "Собака", "Процессор", "Диск", "Программа" ]
var elem = myArray.pop ()
```

После выполнения этого кода в массиве **myArray** останутся:
```
[ "Гвоздь", "Собака", "Процессор", "Диск" ]
```

а значение переменной   `elem`   будет     "Программа"

***

<a name="2"></a>
### :memo: push ()

| [:arrow_heading_up:](#1) | <img width="800"/> | [:arrow_heading_down:](#3) |
|-|-|-|

Этот метод добавляет новый элемент в конец массива

Аргументом, который получает метод при вызове, является добавляемый элемент

Метод возвращает новую длину массива

:coffee:

```javascript
var myArray = [ "Гвоздь", "Велосипед", "Процессор", "Диск" ]
var _length = myArray.push (  "Программа" )
```

После выполнения этого кода в массиве **myArray** будут элементы:
```
[ "Гвоздь", "Велосипед", "Процессор", "Диск", "Программа" ]
```
а значение переменной   **`_length`**   будет     5

***

<a name="3"></a>
### :memo: shift ()

| [:arrow_heading_up:](#2) | <img width="800"/> | [:arrow_heading_down:](#4) |
|-|-|-|

Этот метод удаляет первый элемент из массива

Возвращаемое значение - удаленный элемент

Например, в результате выполнения следующего кода:

:coffee:

```javascript
var arrayOfNames = [ "Мария", "Дмитрий", "Николай", "Сергей" ]
console.log ( arrayOfNames.shift () )
```

в консоли будет:  _Мария_

а массив **arrayOfNames** будет содержать значения:
```
[ "Дмитрий", "Николай", "Сергей" ]
```

***

<a name="4"></a>
### :memo: unshift ()

| [:arrow_heading_up:](#3) | <img width="800"/> | [:arrow_heading_down:](#5) |
|-|-|-|

Метод добавляет новый элемент в начало массива

Возвращаемое значение - новая длина массива ( число )

:coffee:

```javascript
var drinks = [ "кофе", "чай", "сок", "вода", "молоко" ]
var len = drinks.unshift ( "пиво" )
```

В результате массив **drinks** будет содержать элементы:
```
[ "пиво", "кофе", "чай", "сок", "вода", "молоко" ]
```

а переменная `len` примет значение 6

***

<a name="5"></a>
### :memo: splice ()

| [:arrow_heading_up:](#4) | <img width="800"/> | [:arrow_heading_down:](#6) |
|-|-|-|

Первый аргумент ( число ) определяет положение ( индекс ), куда будут вставлены новые элементы

Второй аргумент ( число ) определяет, сколько элементов ( начиная с позиции вставки ) должно быть удалено из массива

Третий ( четвертый, пятый ... ) аргументы - это элементы, которые нужно вставить в массив

Метод возвращает удаленные элементы массива ( массив )

#### :coffee: :one:

С помощью метода splice () можно заменить элементы в массиве:
```javascript
var myArray = [ 1, 2, 3, 4, 5 ] 
console.log ( myArray.splice ( 2, 1, "*" ) )
```

В результате массив **myArray** будет:
```
[ 1, 2, "*", 4, 5 ]
```

а в консоль будет выведено:
```
[ 3 ]
```   

( массив элементов, которые были заменены на  "*" )

***

:coffee: :two:

```javascript
var myArray = [ 1, 2, 3, 4, 5 ] 
console.log ( myArray.splice ( 2, 2, "*", "#", "$", "%" ) )
```

В результате массив **myArray** будет:
```
[ 1, 2, "*", "#", "$", "%", 5 ]
```

а в консоль будет выведено:
```
[ 3, 4 ]
```
( элементы, которые были заменены элементами  "*", "#", "$", "%" )

***

:coffee: :three:

```javascript
var myArray = [ 1, 2, 3, 4, 5 ] 
console.log ( myArray.splice ( 2, 2, [ 7, 8, 9 ] ) )
```

В результате массив **myArray** будет состоять из четырех элементов:
```
[ 1, 2, Array(3), 5 ]
```

а в консоль будет выведено:
```
[ 3, 4 ]
```
( элементы, которые были заменены массивом  [ 7, 8, 9 ] )

***

:coffee: :four:

```javascript
var myArray = [ 1, 2, 3, 4, 5 ] 
console.log ( myArray.splice ( 2, 0, "Новый элемент" ) )
```

В результате массив **myArray** будет состоять из четырех элементов:
```
[ 1, 2, "Новый элемент", 3, 4, 5 ]
```
а в консоль будет выведен пустой массив:
```
[]
```
( ни одного элемента не было удалено из массива, поскольку второй аргумент метода равен нулю )

***

<a name="6"></a>
### :memo: slice ()

| [:arrow_heading_up:](#5) | <img width="800"/> | [:arrow_heading_down:](#7) |
|-|-|-|

Метод создает новый массив, содержащий фрагмент исходного массива

При этом исходный массив не изменяется

Возвращаемое значение - новый массив, являющийся фрагментом исходного массива

_Аргументы_:

* Первый ( число ) - индекс элемента исходного массива, с которого начинается фрагмент
* Второй  ( число ) - индекс элемента исходного массива, до которого продолжается фрагмент

:coffee: :one:

```javascript
var drinks = [ "кофе", "чай", "сок", "вода", "молоко" ]
var newDrinks = drinks.slice ( 1, 2 )

//  Значение newDrinks:  [ "чай" ]
```

:coffee: :two:

```javascript
var drinks = [ "кофе", "чай", "сок", "вода", "молоко" ]
var newDrinks = drinks.slice ( 1, 4 )

//  Значение newDrinks:  [ "чай", "сок", "вода" ]
```

:coffee: :three:

```javascript
var drinks = [ "кофе", "чай", "сок", "вода", "молоко" ]
var newDrinks = drinks.slice ( 2 )
```

Значение **newDrinks**:
```
[ "сок", "вода", "молоко" ]
```
( если опустить второй аргумент, то фрагмент будет взят до конца исходного массива )

***

<a name="7"></a>
### :memo: concat ()

| [:arrow_heading_up:](#6) | <img width="800"/> | [:arrow_heading_down:](#8) |
|-|-|-|

Метод объединяет два или более массива в один массив

Возвращаемое значение - новый массив

⚠️ Исходные массивы не изменятся

:coffee:

```javascript
var ukrainianCities = [ "Киев", "Львов", "Харьков", "Одесса" ]
var europeanCities = [ "Монреаль", "Копенгаген", "Вена", "Лондон" ]
var newArray = ukrainianCities.concat ( europeanCities )
```

Результатом будет новый массив **newArray**:
```
[ "Киев", "Львов", "Харьков", "Одесса", "Монреаль", "Копенгаген", "Вена", "Лондон" ]
```

***

<a name="8"></a>
### :memo: join ()

| [:arrow_heading_up:](#7) | <img width="800"/> | [:arrow_heading_down:](#9) |
|-|-|-|

Объединяет все элементы массива в строку ( "string" )

Аргумент - символ-разделитель

:coffee:

```javascript
var drinks = [ "кофе", "чай", "сок", "вода", "молоко" ]
var drinkStr = drinks.join ( " | " )
```

Значение **drinkStr**:
```
"кофе | чай | сок | вода | молоко"
```

***

<a name="9"></a>
### :memo: includes()

###### ES8 (2017 )

| [:arrow_heading_up:](#8) | <img width="800"/> | [:arrow_heading_down:](#bottom) |
|-|-|-|

Метод **`includes()`** возвращает `true`, когда значение, переданное аргументом, содержится в массиве, или `false` в противном случае

:coffee: :one:

```javascript
var users = [ "Ivan", "Georg", "Stephan" ]

users.includes ( "Stephan" )  // true
users.includes ( "Mary" )     // false
```

:coffee: :two:

Если элементами массива являются объекты, то метод не будет работать

:warning: поскольку массивы и объекты передаются по ссылке, а не по значению 

```javascript
var users = [
    {
        name: "Ivan",
        email: "ivan78@gmail.com"
    },
    {
        name: "Georg",
        email: "georg.klep@gmail.com"
    },
    {
        name: "Stephan",
        email: "stephan.borg@gmail.com"
    }
]

users.includes ( {
    name: "Stephan",
    email: "stephan.borg@gmail.com"
})

//  false
```

:coffee: :three:

```javascript
var points = [
    [ 100, 20 ],
    [ 200, 150 ],
    [ 120, 50 ]
]

points.includes ( [ 100, 20 ] )   // false
```

***

| [:arrow_heading_up:](#8) | <a name="bottom"><img width="800"/></a> | [:arrow_double_up:](#top) |
|-|-|-|

***
### [:briefcase: Тесты](https://garevna.github.io/js-quiz/#arrayMethods)