## :mortar_board: SOLID

###### Принципы про­ек­ти­ро­ва­ния в ООП

* [`Single responsibility`](#1)
* [`Open-closed`](#2)
* [`Liskov substitution`](#3)
* [`Interface segregation`](#4)
* [`Dependency inversion`](#5)

***

Далее речь будет идти о таких сущностях в ООП, как классы, модули или объекты

Проектирование большого и сложного приложения начинается с разработки его архитектуры

Мы не можем написать такое приложение одним огромным и запутанным файлом с кодом

Мы выполняем декомпозицию - разделяем приложение на более простые части

Давайте вместо слова "части" использовать более подходящее для программирования слово **модули**

Модули должны взаимодействовать друг с другом

При этом они не должны ничего знать о внутреннем содержании друг друга

Код модуля, его внутренние переменные и функции должны быть недоступны извне

Значит, каждому модулю нужен **интерфейс**

Под интерфейсом модуля подразумевается система доступа к его функционалу

Мы должны обеспечить закрытость модуля для внешнего вмешательства в его "внутренний мир", при этом обеспечить его открытость для гибкого взаимодействия с другими модулями

Каждый модуль можно, в свою очередь, разложить на еще более простые модули

И так далее...

В процессе неизбежно выяснится, что часть модулей может быть успешно переиспользована в различных частях приложения

Это означает, что переиспользуемые модули не могут находиться в составе модулей, которые их используют

Иначе пришлось бы обращаться из одного модуля к внутреннему содержимому другого, что недопустимо

Мы выделяем такие модули с универсальной функциональностью, чтобы они были доступны из любой части приложения ( с любой глубины )

Теперь встает вопрос о функциональности модулей

Если он будет выполнять множество различных функций, то при обращении к нему нам придется тянуть весь этот функционал вместо того, чтобы взять конкретный инструмент...

Например, что было бы, если бы вместо вызова статического метода `Object.assign` нам пришлось бы тащить всю кучу статических методов Object, а потом использовать только один из них?

`Object.assign` является отдельным модулем, который выполняет конкретную функцию, и не зависит от других статических методов конструктора `Object`

Итак, проектирование архитектуры приложения - важнейший этам разработки

***

<a name="1"></a>
### Single responsibility

Этот принцип обеспечивает четкое разграничение функций ( обязанностей ) модулей

_Один модуль отвечает только за что-то одно_

Что нам дает соблюдение этого принципа?

Первое - мы легко расширяем функциональность путем добавления новых модулей, но не переписываем уже существующие

Это иллюстрируют те же статические методы `Object`, которые добавляются в каждой новой спецификации языка

Рассмотрим пример объекта `user`, который изначально имел два метода - `read` и `write`

Затем мы решаем добавить объекту `user` еще один метод - изменить свою аватарку

Нам не приходится изменять код методов `read` и `write`

Мы просто добавляем новый метод с конкретной функциональностью

Позже мы сможем еще больше расширить возможности объекта `user`, добавляя новые и новые методы

***

<a name="2"></a>
### Open-closed

Пример выше отлично иллюстрирует также и этот приницип

Объект `user` _открыт для расширения_, но при этом исходный код его модулей _закрыт для изменения_

Мы можем написать интерфейс, позволяющий подключать экземпляру `user` необходимые методы

```javascript
class User {
    constructor ( name ) {
        this.name = name
    }
}

User.updateMethods = function ( methodName, func ) {
    this.prototype [ methodName ] = func
}

User.updateMethods ( "write", function ( message ) {
    console.log ( `${this.name}: ${message}` )
})

let user = new User ( "Иван" )
user.write ( "Hello!" )
```

В консоли мы увидим

```console
Иван: Hello!
```

В этом примере у класса **`User`** предусмотрен интерфейс **_`updateMethods`_**, расширяющий функциональность экземпляров класса

Давайте используем этот интерфейс для создания нового метода:

```javascript
User.updateMethods ( "voyage", function ( city ) {
    console.log ( `${this.name}: I visit ${city}` )
})
```

Теперь вызовем новый метод

```javascript
user.voyage ( "London" )
```

В консоли мы увидим

```console
Иван: I visit London
```

:warning: Обратите внимание, что для расширения функционала класса нам не потребовалось изменять код существующих модулей

***

<a name="3"></a>
### Liskov substitution

Прин­цип под­ста­новки Бар­бары Лис­ков заключается в следующем:

работоспособность кода не должна быть нарушена в результате замены экземпляра класса на экземпляр наследующего класса

это вполне логично: если производный класс только расширяет функциональность базового класса, не изменяя его, то при такой замене все функции базового класса продолжают работать так же, как и ранее

Нам не нужно переписывать модули, работавшие с экземпляром базового класса

В общем-то, это всего лишь соблюдение принципов наследования...

:coffee:

Если мы расширим ранее объявленный класс **`User`** следующим образом:

```javascript
class RegisteredUser extends User {
    constructor ( name, token ) {
        super ( name )
        let auth = token
        this.setIdentity ( token )
        this.testIdentity = () => this.getIdentity () === auth
    }
    getIdentity () {
        let token = document.cookie.split("; ")
            .filter ( item => item.indexOf ( "auth" ) === 0 )[0]
        return token ? token.split( "=" )[1] : null
    }
    setIdentity ( auth ) {
        document.cookie = `auth=${auth}`
    }
}
```

и заменим ранее созданный экземпляр `user` на экземпляр нового класса:

```javascript
user = new RegisteredUser ( "Иван", "xJgb-809/**1Bh" )
```

то это не приведет к нарушению нормальной работы модулей, оперировавших старым экземпляром `user`

***

<a name="4"></a>
### Interface segregation

Как мы уже поняли :wink:, модули взаимодействуют друг с другом через интерфейсы

Под интерфейсом мы понимаем публичные методы экземпляра

Дробление интефесов - нормальная практика: если вы написали метод, который делает слишком много разного, вы уже нарушили первый принцип `SOLID`

Если каждый интефейсный метод экземпляра выполняет одну узкоспециализированную функцию, то нам не нужно его модифицировать при необходимости расширить функциональность модуля

Достаточно добавить еще один узкоспециализированный интерфейсный метод

Например, вернемся к нашему классу **`User`** с его методом **_`write`_**

Предположим, что этот метод может:

* выводить сообщение в консоль
* выводить сообщение на страницу
* выводить сообщение во всплывающем окне

это плохой интерфейс

Нужно три отдельных метода, каждый из которых реализует одну из вышеперечисленных функций

Очевидно, что принцип специализации интерфейсов непосредственно вытекает из первого принципа `SOLID`

***

<a name="5"></a>
### Dependency Invertion

Зависимости...

Что от чего зависит в вашем приложении?

С самого начала вы должны это хорошо продумать

Этот принцип легче всего нарушить в JS, поскольку у нас есть свойство `__proto__` экземпляра, которое делает доступным прототип базового класса из экземпляра класса

Пример грубого нарушения этого принципа:

```javascript
User.updateMethods ( "sedition", function ( prop, val ) {
    this.__proto__[prop] = val
})

user.sedition ( "badExample", "You should not do this" )
```

В этом примере мы предоставили доступ экземплярам к прототипу

:warning: Но прототип не должен зависеть от экземпляров

Каждый класс является абстрацией

Каждый производный класс является детализацией абстрации верхнего уровня

В примере, приведенном ранее, класс **`RegisteredUser`** является детализией класса **`User`**

Другими словами, класс **`User`** является абстрацией более высокого уровня, чем класс **`RegisteredUser`**

Поэтому нормально, что класс **`RegisteredUser`** зависит от класса **`User`**, но никак не наоборот 

:warning: Обратная зависимость недопустима