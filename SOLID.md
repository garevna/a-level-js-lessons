## :mortar_board: SOLID

###### Принципы про­ек­ти­ро­ва­ния в ООП

* Single responsibility
* Open-closed
* Liskov substitution
* Interface segregation
* Dependency inversion

***

Далее речь будет идти о таких сущностях в ООП, как классы, модули или объекты

Проектирование большого и сложного приложения начинается с разработки его архитектуры

Мы не можем написать такое приложение одним огромным и запутанным файлом с кодом

Мы выполняем декомпозицию - разделяем приложение на более простые части

Давайте вместо слова "части" использовать более подходящее для программирования слово **модули**

Модули должны взаимодействовать друг с другом

При этом они не должны ничего знать о внутреннем содержании друг друга

Код модуля, его внутренние переменные и функции должны быть недоступны извне

Значит, каждому модулю нужен **интерфейс**

Под интерфейсом модуля подразумевается система доступа к его функционалу

Мы должны обеспечить закрытость модуля для внешнего вмешательства в его "внутренний мир", при этом обеспечить его открытость для гибкого взаимодействия с другими модулями

Каждый модуль можно, в свою очередь, разложить на еще более простые модули

И так далее...

В процессе неизбежно выяснится, что часть модулей может быть успешно переиспользована в различных частях приложения

Это означает, что переиспользуемые модули не могут находиться в составе модулей, которые их используют

Иначе пришлось бы обращаться из одного модуля к внутреннему содержимому другого, что недопустимо

Мы выделяем такие модули с универсальной функциональностью, чтобы они были доступны из любой части приложения ( с любой глубины )

Теперь встает вопрос о функциональности модулей

Если он будет выполнять множество различных функций, то при обращении к нему нам придется тянуть весь этот функционал вместо того, чтобы взять конкретный инструмент...

Например, что было бы, если бы вместо вызова статического метода `Object.assign` нам пришлось бы тащить всю кучу статических методов Object, а потом использовать только один из них?

`Object.assign` является отдельным модулем, который выполняет конкретную функцию, и не зависит от других статических методов конструктора `Object`

Итак, проектирование архитектуры приложения - важнейший этам разработки

***

### Single responsibility

Этот принцип обеспечивает четкое разграничение функций ( обязанностей ) модулей

_Один модуль отвечает только за что-то одно_

Что нам дает соблюдение этого принципа?

Первое - мы легко расширяем функциональность путем добавления новых модулей, но не переписываем уже существующие

Это иллюстрируют те же статические методы `Object`, которые добавляются в каждой новой спецификации языка

Рассмотрим пример объекта `user`, который изначально имел два метода - `read` и `write`

Затем мы решаем добавить объекту `user` еще один метод - изменить свою аватарку

Нам не приходится изменять код методов `read` и `write`

Мы просто добавляем новый метод с конкретной функциональностью

Позже мы сможем еще больше расширить возможности объекта `user`, добавляя новые и новые методы

***

### Open-closed

Пример выше отлично иллюстрирует также и этот приницип

Объект `user` _открыт для расширения_, но при этом исходный код его модулей _закрыт для изменения_

Мы можем написать интерфейс, позволяющий подключать экземпляру `user` необходимые методы

```javascript
class User {
    constructor ( name ) {
        this.name = name
    }
}

User.updateMethods = function ( methodName, func ) {
    this.prototype [ methodName ] = func
}

User.updateMethods ( "write", function ( message ) {
    console.log ( `${this.name}: ${message}` )
})

var user = new User ( "Иван" )
user.write ( "Hello!" )
```

В консоли мы увидим

```console
Иван: Hello!
```

В этом примере у класса **`User`** предусмотрен интерфейс **_`updateMethods`_**, расширяющий функциональность экземпляров класса

Давайте используем этот интерфейс для создания нового метода:

```javascript
User.updateMethods ( "voyage", function ( city ) {
    console.log ( `${this.name}: I visit ${city}` )
})
```

Теперь вызовем новый метод

```javascript
user.voyage ( "London" )
```

В консоли мы увидим

```console
Иван: I visit London
```

***

### Liskov substitution

